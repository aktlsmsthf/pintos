			+---------------------------+
			|	      CS 330			|
			| PROJECT 3: VIRTUAL MEMORY	|
			|	   DESIGN DOCUMENT		|
			+---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

이창훈 lch7224@kaist.ac.kr
이승호 konglsh@kaist.ac.kr

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: 
struct thread{
  ...
  struct list mapped_list; //list that saves mapped files
  struct hash spt;         //supplemental page table
  ...
}
    
struct spt_entry{          //struct for supplemental page table elements
  void *page;              //virtual address
  struct hash_elem elem;   //hash_elem
  struct frame_entry* fe;  //frame table entry whose frame is connected to virtual address 
  bool writable;           //check if the page is writable
  enum palloc_flags flags; //flags used to palloc
  bool lazy;               //check if it is lazy load, used at page fault handler
  size_t read_bytes;       //used to lazy load
  size_t zero_bytes;       //used to lazy load
  struct file *file;       //used to lazy load
  struct thread *t;        //threads where spt is
  off_t ofs;               //used to lazy load
};


struct list frame_table;   //frame table

struct frame_entry{        //struct for frame table entry
  void *frame;             //physical address (kernel address) 
  bool in_swap;            //check if the data is moved to swap table(bitmap) 
  size_t swap_where;       //(if in_swap is true) the index of swap table where the data is 
  struct spt_entry * spte; //spt entry whose page is connected to frame
  struct list_elem elem;   //list_elem
};


---- ALGORITHMS ----

>> A2: 
1.stack growth(frame_spt_alloc)
page를 allocate할 때 위에 설명된 frame_entry 와 spt_entry를 할당하여 각각 list와 hash table에 넣어줍니다.
그리고 두 entry를 포인터로 서로 기억하게 하여 
frame entry에서 spt entry로 spt entry에서 frame entry에서 spt entry로 각각 search가 가능하도록합니다.

그리고 frame entry 내에 swap과 관련된 정보를 저장하여 
swap out/in이 일어날 경우에도 spt entry는 연결된 frame만 알면 해당하는 page를(physical) 찾을 수 있도록 했습니다. 

2.lazy load
처음 spt와 frame table을 구현할때에는 lazyload를 생각하지 않았기 때문에 lazy load를 구현하기 위해서는 
새로운 allocate 방식이 필요했습니다. 

따라서 file_frame_alloc와 spt_alloc_lazy라는 frame allocate와 spt allocate가 분리된 새로운 방식을 구현했습니다.
spt_alloc_lazy에서는 allocate할 파일의 정보를 spte에 담고, 
file_frame_alloc은 page fault가 일어날 경우 call되어 spte에 담겨진 파일의 정보를 frame을 할당하여 읽어옵니다.

3. frame eviction
더 이상 palloc이 불가능 할경우(palloc_get_page 의 return이 NULL일 경우) frame eviction이 일어나도록 합니다.
frame eviction 에는 second chance algorithm을 사용했니다.
frame list를 순회하며 is_accessed를 체크하고 그 값이 0일 경우에는 해당 frame을 evict하고 
1일 경우에는 0으로 설정하며 list의 맨 뒷자리로 옮겨줍니다.


>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

kernel address의 page에 대해서는 따로 frame entry를 할당하지 않기때문에
(userprogram 에서 사용되는 page에 대해서만 frame 할당)
해당하는 문제는 피할 수 있습니다.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

lock을 이용한 syncronization을 통해 해결했습니다.
frame table 에 접근하는(변화를 주는) 함수(allocate, eviction, remove)에는 lock을 걸어 race problem 을 방지했습니다.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

supplemental page table(spt)에는 hash table을 사용했습니다.
spt의 경우에는 각각 entry를 search해야할 경우가 굉장히 많고(page fault 등)
각 page를 순회해야할 경우는 전혀 없기 때문에(destroy를 제외), 
search의 time cost가 적은 hash table이 좋다고 생각했습니다.

frame table에는 list를 사용했습니다.
frame table은 eviction을 자주해야하기 때문에 각 entry를 순회해야할 경우가 많아서
순회가 편리한 list를 선택했습니다.

swap table은 swap out과 in의 경우 저장할 혹은 불러올 데이터의 위치만 알면 충분하기 떄문에
간단한 bitmap을 사용했습니다.

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct bitmap *swap_table ;
struct disk *swap_disk ;

struct frame_entry{       
  ...
  bool in_swap;            //check if the data is moved to swap table(bitmap) 
  size_t swap_where;       //(if in_swap is true) the index of swap table where the data is 
  ...
};


---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

더 이상 palloc이 불가능 할경우(palloc_get_page 의 return이 NULL일 경우) frame eviction이 일어나도록 합니다.
frame eviction 에는 second chance algorithm을 사용했니다.
frame list를 순회하며 is_accessed를 체크하고 그 값이 0일 경우에는 해당 frame을 evict하고 
1일 경우에는 0으로 설정하며 list의 맨 뒷자리로 옮겨줍니다.

순회중인 entry중 swap out이 이미 진행되었을 경우에는, 해당 entry를 지우지않고 
void * frame (physical address)를 NULL로 설정해 놓았습니다.
따라서 second chance알고리즘에서 순회 중에 frame entry->frame == NULL 인 경우는 건너 뛰도록 했습니다. 


>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

특별히 해당 frame이 존재하지 않게 되었음을 표시해주지는 않았습니다.
다만 swap out하는 과정에서 pagedir_clear_page()함수를 이용해 다시 해당 page에 접근할 경우
page fault가 일어나서 handler가 해당 작업을 처리하도록 했습니다.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

esp-32를 기준선으로 정하였습니다. PUSHA를 통해 32bytes를 넣을 수 있기 때문에
user virtual address면서 esp-32 보다 작으면 invalid page fault로 하였고 esp-32 이상이면
stack growth를 하게 설정하였습니다.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

frame table 에 접근할 때 사용되는 lock,
system call 에 이용되는 lock
swap in/out 시 사용되는 lock 3개를 이용하여 synchronization을 했습니다.


>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

evict를 할 때 swap_out을 합니다. evict되는 frame을 쓰던 process에서는 swap_out되는 순간
page fault가 발생합니다. 그러면 swap_in을 합니다. 이때 swap_out과 swap_in은 swap_lock으로 인해
동시해 발생할 수 없어서 race가 발생하지 않습니다.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

eviction 과정에서 accessed bit를 체크하여 accessed bit가 0인 frame을 evict하도록 했습니다..

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

invalid virtual address에 접근할 경우엔
system call내에서 사용되는 변수의 포인터들을 확인하여 exit(-1)하도록 했습니다.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

위에서 말했듯이 3개의 lock을 사용했습니다. 
먼저 단 하나의 lock을 사용할 경우 parallelism이 전혀 안되기 때문에,
둘 이상의 lock이 필요했고, 
너무 많은 lock을 사용할 경우 각각에 대한 판단이 어렵기 때문에
3개가 적당하다고 생각했습니다.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread
  {
    ...
    struct list mapped_list;//thread contain memory mapped files it has
    ...
}


struct mmapped{             //mapped_list entry
  int mid;                  //fd of mapped file
  struct file *file;        //pointer of mapped file
  void *addr;               //virtual address where the file mapped
  uint32_t size;            //read byte of mapped file(file length)
  struct list_elem elem;    //list_elem
};



---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

(A2)2.lazy load
처음 spt와 frame table을 구현할때에는 lazyload를 생각하지 않았기 때문에 lazy load를 구현하기 위해서는 
새로운 allocate 방식이 필요했습니다. 

따라서 file_frame_alloc와 spt_alloc_lazy라는 frame allocate와 spt allocate가 분리된 새로운 방식을 구현했습니다.
spt_alloc_lazy에서는 allocate할 파일의 정보를 spte에 담고, 
file_frame_alloc은 page fault가 일어날 경우 call되어 spte에 담겨진 파일의 정보를 frame을 할당하여 읽어옵니다.

위의 lazy load와 memory map은 큰 차이가 없었습니다. 
따라서 같은 방식으로 구현했습니다.
mmap이 call 될때 해당 파일에 대해 spt_alloc_lazy를 사용하고
page fault가 일어났을때 file_frame_alloc을 통해 file을 가져옵니다. 

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

if(addr==NULL || (int)addr%PGSIZE != 0 || pagedir_get_page(thread_current()->pagedir, addr)!=NULL)
이 조건문으로 address가 null이거나 page align 되어있지 않거나 해당 address를 이용하는 page가 존재할경우
-1을 return 하도록 하였습니다 

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

문제에서 설명했듯이 lazy loading을 한다는 점이나 파일을 읽는다는 점이 비슷하여
supplemental page table entry를 할당하거나 page fault가 발생해 load를 하는 코드 등을 
공유하여 사용하였습니다.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
